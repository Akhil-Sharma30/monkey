import logging
from abc import abstractmethod
from datetime import datetime
from typing import Dict

from common.utils.exceptions import FailedExploitationError
from common.utils.exploit_enum import ExploitType
from infection_monkey.config import WormConfiguration
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.telemetry.messengers.i_telemetry_messenger import ITelemetryMessenger

from . import IAgentRepository

logger = logging.getLogger(__name__)


class HostExploiter:
    _TARGET_OS_TYPE = []

    # Usual values are 'vulnerability' or 'brute_force'
    EXPLOIT_TYPE = ExploitType.VULNERABILITY

    # Determines if successful exploitation should stop further exploit attempts on that machine.
    # Generally, should be True for RCE type exploiters and False if we don't expect the
    # exploiter to run the monkey agent.
    # Example: Zerologon steals credentials
    RUNS_AGENT_ON_SUCCESS = True

    @property
    @abstractmethod
    def _EXPLOITED_SERVICE(self):
        pass

    def __init__(self):
        self._config = WormConfiguration
        self.exploit_info = {
            "display_name": self._EXPLOITED_SERVICE,
            "started": "",
            "finished": "",
            "vulnerable_urls": [],
            "vulnerable_ports": [],
            "executed_cmds": [],
        }
        self.exploit_attempts = []
        self.host = None
        self.telemetry_messenger = None
        self.options = {}
        self.exploit_result = {}

    def set_start_time(self):
        self.exploit_info["started"] = datetime.now().isoformat()

    def set_finish_time(self):
        self.exploit_info["finished"] = datetime.now().isoformat()

    def is_os_supported(self):
        return self.host.os.get("type") in self._TARGET_OS_TYPE

    def report_login_attempt(self, result, user, password="", lm_hash="", ntlm_hash="", ssh_key=""):
        self.exploit_attempts.append(
            {
                "result": result,
                "user": user,
                "password": password,
                "lm_hash": lm_hash,
                "ntlm_hash": ntlm_hash,
                "ssh_key": ssh_key,
            }
        )

    # TODO: host should be VictimHost, at the moment it can't because of circular dependency
    def exploit_host(
        self,
        host,
        current_depth: int,
        telemetry_messenger: ITelemetryMessenger,
        agent_repository: IAgentRepository,
        options: Dict,
    ):
        self.host = host
        self.current_depth = current_depth
        self.telemetry_messenger = telemetry_messenger
        self.agent_repository = agent_repository
        self.options = options

        self.pre_exploit()
        try:
            return self._exploit_host()
        except FailedExploitationError as e:
            logger.debug(f"Exploiter failed: {e}.")
            raise e
        except Exception as e:
            logger.error("Exception in exploit_host", exc_info=True)
            raise e
        finally:
            self.post_exploit()

    def pre_exploit(self):
        self.exploit_result = ExploiterResultData(
            os=self.host.os.get("type"), info=self.exploit_info, attempts=self.exploit_attempts
        )
        self.set_start_time()

    def post_exploit(self):
        self.set_finish_time()

    @abstractmethod
    def _exploit_host(self):
        raise NotImplementedError()

    def add_vuln_url(self, url):
        self.exploit_info["vulnerable_urls"].append(url)

    def add_vuln_port(self, port):
        self.exploit_info["vulnerable_ports"].append(port)

    def add_executed_cmd(self, cmd):
        """
        Appends command to exploiter's info.
        :param cmd: String of executed command. e.g. 'echo Example'
        """
        powershell = True if "powershell" in cmd.lower() else False
        self.exploit_info["executed_cmds"].append({"cmd": cmd, "powershell": powershell})
