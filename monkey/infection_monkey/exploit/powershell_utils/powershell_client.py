import abc
import logging
from typing import Optional, Union

import pypsrp
import spnego
from pypsrp.client import Client
from pypsrp.exceptions import AuthenticationError  # noqa: F401
from pypsrp.powershell import PowerShell, RunspacePool
from typing_extensions import Protocol
from urllib3 import connectionpool

from infection_monkey.exploit.consts import WIN_ARCH_32, WIN_ARCH_64
from infection_monkey.exploit.powershell_utils.auth_options import AuthOptions
from infection_monkey.exploit.powershell_utils.credentials import Credentials, SecretType
from infection_monkey.model import GET_ARCH_WINDOWS

logger = logging.getLogger(__name__)

CONNECTION_TIMEOUT = 3  # Seconds


def _set_sensitive_packages_log_level_to_error():
    # If root logger is inherited, extensive and potentially sensitive info could be logged
    sensitive_packages = [pypsrp, spnego, connectionpool]
    for package in sensitive_packages:
        logging.getLogger(package.__name__).setLevel(logging.ERROR)


def format_password(credentials: Credentials) -> Optional[str]:
    if credentials.secret_type == SecretType.CACHED:
        return None

    if credentials.secret_type == SecretType.PASSWORD:
        return credentials.secret

    if credentials.secret_type == SecretType.LM_HASH:
        return f"{credentials.secret}:00000000000000000000000000000000"

    if credentials.secret_type == SecretType.NT_HASH:
        return f"00000000000000000000000000000000:{credentials.secret}"

    raise ValueError(f"Unknown secret type {credentials.secret_type}")


class IPowerShellClient(Protocol, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def execute_cmd(self, cmd: str) -> str:
        pass

    @abc.abstractmethod
    def get_host_architecture(self) -> Union[WIN_ARCH_32, WIN_ARCH_64]:
        pass

    @abc.abstractmethod
    def copy_file(self, src: str, dest: str) -> bool:
        pass

    @abc.abstractmethod
    def execute_cmd_as_detached_process(self, cmd: str):
        pass


class PowerShellClient(IPowerShellClient):
    def __init__(self, ip_addr, credentials: Credentials, auth_options: AuthOptions):
        _set_sensitive_packages_log_level_to_error()

        self._ip_addr = ip_addr
        self._client = Client(
            ip_addr,
            username=credentials.username,
            password=format_password(credentials),
            cert_validation=False,
            auth=auth_options.auth_type,
            encryption=auth_options.encryption,
            ssl=auth_options.ssl,
            connection_timeout=CONNECTION_TIMEOUT,
        )

        # attempt to execute dir command to know if authentication was successful
        self.execute_cmd("dir")

    def execute_cmd(self, cmd: str) -> str:
        output, _, _ = self._client.execute_cmd(cmd)
        return output

    def get_host_architecture(self) -> Union[WIN_ARCH_32, WIN_ARCH_64]:
        output = self._client.execute_cmd(GET_ARCH_WINDOWS)
        if "64-bit" in output:
            return WIN_ARCH_64

        return WIN_ARCH_32

    def copy_file(self, src: str, dest: str) -> bool:
        try:
            self._client.copy(src, dest)
            logger.debug(f"Successfully copied {src} to {dest} on {self._ip_addr}")

            return True
        except Exception as ex:
            logger.error(f"Failed to copy {src} to {dest} on {self._ip_addr}: {ex}")

        return False

    def execute_cmd_as_detached_process(self, cmd: str):
        logger.debug(
            f"Attempting to execute a command on the remote host as a detached process - "
            f"Host: {self._ip_addr}, Command: {cmd}"
        )
        with self._client.wsman, RunspacePool(self._client.wsman) as pool:
            ps = PowerShell(pool)
            ps.add_cmdlet("Invoke-WmiMethod").add_parameter("path", "win32_process").add_parameter(
                "name", "create"
            ).add_parameter("ArgumentList", cmd)
            ps.invoke()
