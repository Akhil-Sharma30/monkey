import logging
from queue import Queue
from threading import Barrier, Event
from unittest.mock import MagicMock

import pytest

from infection_monkey.master import Exploiter
from infection_monkey.model import VictimHost
from infection_monkey.puppet.mock_puppet import MockPuppet

logger = logging.getLogger()


@pytest.fixture(autouse=True)
def patch_queue_timeout(monkeypatch):
    monkeypatch.setattr("infection_monkey.master.exploiter.QUEUE_TIMEOUT", 0.001)


@pytest.fixture
def scan_completed():
    return Event()


@pytest.fixture
def stop():
    return Event()


@pytest.fixture
def callback():
    return MagicMock()


@pytest.fixture
def exploiter_config():
    return {
        "options": {"dropper_path_linux": "/tmp/monkey"},
        "brute_force": [
            {"name": "PowerShellExploiter", "options": {"timeout": 10}},
            {"name": "SSHExploiter", "options": {}},
        ],
        "vulnerability": [
            {"name": "ZerologonExploiter", "options": {}},
        ],
    }


@pytest.fixture
def hosts():
    return [VictimHost("10.0.0.1"), VictimHost("10.0.0.3")]


@pytest.fixture
def hosts_to_exploit(hosts):
    q = Queue()
    q.put(hosts[0])
    q.put(hosts[1])

    return q


CREDENTIALS_FOR_PROPAGATION = {"usernames": ["m0nk3y", "user"], "passwords": ["1234", "pword"]}


def get_credentials_for_propagation():
    return CREDENTIALS_FOR_PROPAGATION


@pytest.fixture
def run_exploiters(exploiter_config, hosts_to_exploit, callback, scan_completed, stop):
    def inner(puppet, num_workers):
        # Set this so that Exploiter() exits once it has processed all victims
        scan_completed.set()

        e = Exploiter(puppet, num_workers, get_credentials_for_propagation)
        e.exploit_hosts(exploiter_config, hosts_to_exploit, callback, scan_completed, stop)

    return inner


def test_exploiter(callback, hosts, hosts_to_exploit, run_exploiters):
    run_exploiters(MockPuppet(), 2)

    assert callback.call_count == 5
    host_exploit_combos = set()

    for i in range(0, 5):
        victim_host = callback.call_args_list[i][0][0]
        exploiter_name = callback.call_args_list[i][0][1]
        host_exploit_combos.add((victim_host, exploiter_name))

    assert ("ZerologonExploiter", hosts[0]) in host_exploit_combos
    assert ("PowerShellExploiter", hosts[0]) in host_exploit_combos
    assert ("ZerologonExploiter", hosts[1]) in host_exploit_combos
    assert ("PowerShellExploiter", hosts[1]) in host_exploit_combos
    assert ("SSHExploiter", hosts[1]) in host_exploit_combos


def test_credentials_passed_to_exploiter(run_exploiters):
    mock_puppet = MagicMock()
    run_exploiters(mock_puppet, 1)

    for call_args in mock_puppet.exploit_host.call_args_list:
        assert call_args[0][2].get("credentials") == CREDENTIALS_FOR_PROPAGATION


def test_stop_after_callback(exploiter_config, callback, scan_completed, stop, hosts_to_exploit):
    callback_barrier_count = 2

    def _callback(*_):
        # Block all threads here until 2 threads reach this barrier, then set stop
        # and test that neither thread continues to scan.
        _callback.barrier.wait()
        stop.set()

    _callback.barrier = Barrier(callback_barrier_count)

    stoppable_callback = MagicMock(side_effect=_callback)

    # Intentionally NOT setting scan_completed.set(); _callback() will set stop

    e = Exploiter(MockPuppet(), callback_barrier_count + 2, get_credentials_for_propagation)
    e.exploit_hosts(exploiter_config, hosts_to_exploit, stoppable_callback, scan_completed, stop)

    assert stoppable_callback.call_count == 2


def test_exploiter_raises_exception(callback, hosts, hosts_to_exploit, run_exploiters):
    error_message = "Unexpected error"
    mock_puppet = MockPuppet()
    mock_puppet.exploit_host = MagicMock(side_effect=Exception(error_message))
    run_exploiters(mock_puppet, 3)

    assert callback.call_count == 6

    for i in range(0, 6):
        exploit_result_data = callback.call_args_list[i][0][2]
        assert exploit_result_data.exploitation_success is False
        assert exploit_result_data.propagation_success is False
        assert error_message in exploit_result_data.error_message
