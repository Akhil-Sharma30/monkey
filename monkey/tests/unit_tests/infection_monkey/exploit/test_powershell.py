from collections import namedtuple
from unittest.mock import MagicMock

import pytest

from infection_monkey.exploit import powershell
from infection_monkey.exploit.consts import WIN_ARCH_32, WIN_ARCH_64
from infection_monkey.exploit.powershell_utils.auth_options import AuthOptions
from infection_monkey.exploit.powershell_utils.credentials import Credentials
from infection_monkey.model.host import VictimHost

USER_LIST = ["user1", "user2"]
PASSWORD_LIST = ["pass1", "pass2"]
LM_HASH_LIST = ["bogo_lm_1"]
NT_HASH_LIST = ["bogo_nt_1", "bogo_nt_2"]
DROPPER_TARGET_PATH_32 = "C:\\agent32"
DROPPER_TARGET_PATH_64 = "C:\\agent64"

Config = namedtuple(
    "Config",
    [
        "exploit_user_list",
        "exploit_password_list",
        "exploit_lm_hash_list",
        "exploit_ntlm_hash_list",
        "dropper_target_path_win_32",
        "dropper_target_path_win_64",
    ],
)


class TestAuthenticationError(Exception):
    pass


@pytest.fixture
def powershell_exploiter(monkeypatch):
    host = VictimHost("127.0.0.1")
    pe = powershell.PowerShellExploiter(host)
    pe._config = Config(
        USER_LIST,
        PASSWORD_LIST,
        LM_HASH_LIST,
        NT_HASH_LIST,
        DROPPER_TARGET_PATH_32,
        DROPPER_TARGET_PATH_64,
    )

    monkeypatch.setattr(powershell, "AuthenticationError", TestAuthenticationError)
    monkeypatch.setattr(powershell, "is_windows_os", lambda: True)
    # It's regrettable to mock out a private method on the PowerShellExploiter instance object, but
    # it's necessary to avoid having to deal with the monkeyfs
    monkeypatch.setattr(pe, "_write_virtual_file_to_local_path", lambda: None)

    return pe


def test_powershell_disabled(monkeypatch, powershell_exploiter):
    mock_powershell_client = MagicMock(side_effect=Exception)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)

    success = powershell_exploiter.exploit_host()
    assert not success


def test_powershell_http(monkeypatch, powershell_exploiter):
    def allow_http(_, credentials: Credentials, auth_options: AuthOptions):
        if not auth_options.ssl:
            raise TestAuthenticationError
        else:
            raise Exception

    mock_powershell_client = MagicMock(side_effect=allow_http)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)
    powershell_exploiter.exploit_host()

    for call_args in mock_powershell_client.call_args_list:
        assert not call_args[0][2].ssl


def test_powershell_https(monkeypatch, powershell_exploiter):
    def allow_https(_, credentials: Credentials, auth_options: AuthOptions):
        if auth_options.ssl:
            raise TestAuthenticationError
        else:
            raise Exception

    mock_powershell_client = MagicMock(side_effect=allow_https)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)
    powershell_exploiter.exploit_host()

    for call_args in mock_powershell_client.call_args_list:
        if call_args[0][1].secret != "" and call_args[0][1].secret != "dummy_password":
            assert call_args[0][2].ssl


def test_no_valid_credentials(monkeypatch, powershell_exploiter):
    mock_powershell_client = MagicMock(side_effect=TestAuthenticationError)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)

    success = powershell_exploiter.exploit_host()
    assert not success


def authenticate(mock_client):
    def inner(_, credentials: Credentials, auth_options: AuthOptions):
        if credentials.username == "user1" and credentials.secret == "pass2":
            return mock_client
        else:
            raise TestAuthenticationError("Invalid credentials")

    return inner


@pytest.mark.parametrize(
    "dropper_target_path,arch",
    [(DROPPER_TARGET_PATH_32, WIN_ARCH_32), (DROPPER_TARGET_PATH_64, WIN_ARCH_64)],
)
def test_successful_copy(monkeypatch, powershell_exploiter, dropper_target_path, arch):
    mock_client = MagicMock()
    mock_client.get_host_architecture = lambda: arch
    mock_client.copy_file = MagicMock(return_value=True)

    mock_powershell_client = MagicMock(side_effect=authenticate(mock_client))
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)

    success = powershell_exploiter.exploit_host()

    assert dropper_target_path in mock_client.copy_file.call_args[0][1]
    assert success


def test_failed_copy(monkeypatch, powershell_exploiter):
    mock_client = MagicMock()
    mock_client.get_host_architecture = lambda: WIN_ARCH_32
    mock_client.copy_file = MagicMock(return_value=False)

    mock_powershell_client = MagicMock(side_effect=authenticate(mock_client))
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)

    success = powershell_exploiter.exploit_host()
    assert not success


def test_failed_monkey_execution(monkeypatch, powershell_exploiter):
    mock_client = MagicMock()
    mock_client.get_host_architecture = lambda: WIN_ARCH_32
    mock_client.copy_file = MagicMock(return_value=True)
    mock_client.execute_cmd_as_detached_process = MagicMock(side_effect=Exception)

    mock_powershell_client = MagicMock(side_effect=authenticate(mock_client))
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)

    success = powershell_exploiter.exploit_host()
    assert not success


def test_login_attemps_correctly_reported(monkeypatch, powershell_exploiter):
    mock_client = MagicMock()
    mock_client.get_host_architecture = lambda: WIN_ARCH_32
    mock_client.copy_file = MagicMock(return_value=True)
    mock_client.execute_cmd_as_detached_process = MagicMock(side_effect=Exception)

    def allow_ntlm(_, credentials: Credentials, auth_options: AuthOptions):
        if credentials.username == USER_LIST[1] and credentials.secret == NT_HASH_LIST[1]:
            return mock_client

        raise TestAuthenticationError

    mock_powershell_client = MagicMock(side_effect=allow_ntlm)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client)

    powershell_exploiter.exploit_host()

    assert {
        "result": False,
        "user": USER_LIST[1],
        "password": None,
        "lm_hash": "",
        "ntlm_hash": "",
        "ssh_key": "",
    } in powershell_exploiter.exploit_attempts

    assert {
        "result": False,
        "user": USER_LIST[1],
        "password": PASSWORD_LIST[0],
        "lm_hash": "",
        "ntlm_hash": "",
        "ssh_key": "",
    } in powershell_exploiter.exploit_attempts

    assert {
        "result": False,
        "user": USER_LIST[0],
        "password": "",
        "lm_hash": LM_HASH_LIST[0],
        "ntlm_hash": "",
        "ssh_key": "",
    } in powershell_exploiter.exploit_attempts

    assert {
        "result": False,
        "user": USER_LIST[1],
        "password": "",
        "lm_hash": "",
        "ntlm_hash": NT_HASH_LIST[0],
        "ssh_key": "",
    } in powershell_exploiter.exploit_attempts

    assert {
        "result": True,
        "user": USER_LIST[1],
        "password": "",
        "lm_hash": "",
        "ntlm_hash": NT_HASH_LIST[1],
        "ssh_key": "",
    } in powershell_exploiter.exploit_attempts
