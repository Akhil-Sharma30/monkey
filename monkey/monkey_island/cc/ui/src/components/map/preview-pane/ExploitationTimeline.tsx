import _ from 'lodash';
import React, {useEffect, useState} from 'react';
import MapNode from '../../types/MapNode';
import {OverlayTrigger, Tooltip} from 'react-bootstrap';
import {FontAwesomeIcon} from '@fortawesome/react-fontawesome';
import {faQuestionCircle} from '@fortawesome/free-solid-svg-icons/faQuestionCircle';
import IslandHttpClient, {APIEndpoint} from '../../IslandHttpClient';
import LoadingIcon from '../../ui-components/LoadingIcon';


type ExploitationAttempt = {
  source: string;
  success: boolean;
  timestamp: Date;
  exploiter_name: string;
}

type ExploitationEvent = {
  source: string;
  success: boolean;
  timestamp: number;
  exploiter_name: string;
  target: string;
}

const ExploitationTimeline = (props: { node: MapNode, allNodes: MapNode[] }) => {

  const [exploitationAttempts, setExploitationAttempts] = useState<ExploitationAttempt[]>([]);
  const [loadingEvents, setLoadingEvents] = useState(true);

  function getExploitationEvents() {
    let url_args = {'type': 'ExploitationEvent'};
    IslandHttpClient.get(APIEndpoint.agentEvents, url_args)
      .then(res => res.body).then(events => {
      setExploitationAttempts(parseEvents(events, props.node));
      setLoadingEvents(false);
    })
  }

  useEffect(() => {
    setLoadingEvents(true);
    getExploitationEvents();
    let oneSecond = 1000;
    const interval = setInterval(() => {
      getExploitationEvents();
    }, oneSecond * 3);

    return () => clearInterval(interval)
  }, [props.node])

  function parseEvents(events: ExploitationEvent[], node: MapNode): ExploitationAttempt[] {
    let exploitationAttempts = [];
    let filteredEvents = events.filter(event => node.hasIp(event.target))
    for (const event of Object.values(filteredEvents)) {
      let iface = node.networkInterfaces.find(iface => iface.includes(event.target))
      if (iface !== undefined) {
        let timestampInMilliseconds: number = event.timestamp * 1000;
        exploitationAttempts.push({
          source: getSourceNodeLabel(event.source),
          success: event.success,
          timestamp: new Date(timestampInMilliseconds),
          exploiterName: event.exploiter_name
        });
      }
    }
    return exploitationAttempts;
  }

  function getSourceNodeLabel(agentId: string): string {
    try{
      return props.allNodes.filter(node => node.agentId === agentId)[0].getLabel()
    } catch {
      return 'Unknown'
    }
  }

  return (
    <div className={'exploit-timeline'}>
      <h4 style={{'marginTop': '2em'}}>
        Exploit Timeline&nbsp;
        {generateToolTip('Timeline of exploit attempts. Red is successful. Gray is unsuccessful')}
      </h4>
      {loadingEvents ? <LoadingIcon/> :
        <ul className="timeline">
          {getAttemptList(exploitationAttempts)}
        </ul>
      }
    </div>
  )
}

function getAttemptList(exploitationAttempts: ExploitationAttempt[]): any {
  if(exploitationAttempts.length === 0){
    return (<li className={'timeline-content'}>No exploits were attempted on this node yet.</li>);
  } else {
    return aggregateExploitationAttempts(_.sortBy(exploitationAttempts, 'timestamp'))
      .map(data => {
        const {data: attempt, count: count} = data;
        return (
          <li key={`${attempt.timestamp}${String(Math.random())}`}>
            <div className={'bullet ' + (attempt.success ? 'bad' : '')}>
              <div className={'event-count'}>{count < 100 ? count : '99+'}</div></div>
            <div className={'timeline-content'} >
              <div>{new Date(attempt.timestamp).toLocaleString()}</div>
              <div>{attempt.source}</div>
              <div>{attempt.exploiterName}</div>
            </div>
          </li>
        );
      })
  }
}

function generateToolTip(text) {
  return (
    <OverlayTrigger placement="top"
                    overlay={<Tooltip id="tooltip">{text}</Tooltip>}
                    delay={{show: 250, hide: 400}}>
      <a><FontAwesomeIcon icon={faQuestionCircle} style={{'marginRight': '0.5em'}}/></a>
    </OverlayTrigger>
  );
}

function aggregateExploitationAttempts(attempts) {
  let aggregatedAttempts = [];

  for (const attempt of attempts) {
    let len = aggregatedAttempts.length;
    if (len > 0 && areEventsIdentical(attempt, aggregatedAttempts[len - 1].data)) {
      aggregatedAttempts[len - 1].count++;
    } else {
      aggregatedAttempts.push({data: _.cloneDeep(attempt), count: 1});
    }
  }

  return aggregatedAttempts;
}

function areEventsIdentical(event_one, event_two) {
  return ((event_one.source === event_two.source) &&
    (event_one.exploiter_name === event_two.exploiter_name) &&
    (event_one.success === event_two.success))
}

export default ExploitationTimeline
